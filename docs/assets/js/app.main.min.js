/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../src/assets/js/modules/arrowsInputNumberStyle.js":
/*!**********************************************************!*\
  !*** ../src/assets/js/modules/arrowsInputNumberStyle.js ***!
  \**********************************************************/
/***/ (() => {

eval("/**\r\n *\r\n * must be this html, look in the snippets:\r\n *\r\n * <div class=\"quantity-block\">\r\n *    <button class=\"quantity-arrow-minus\" type=\"button\"> - </button>\r\n *    <input class=\"quantity-num\" type=\"number\" value=\"1\" />\r\n *    <button class=\"quantity-arrow-plus\" type=\"button\"> + </button>\r\n * </div>\r\n *\r\n *\r\n */\r\n\r\nfunction quantityProducts() {\r\n  const QuantityBlocks = document.querySelectorAll(`.quantity`); // class of blocks quantity\r\n  const changeEvent = new Event('change', { bubbles: true });\r\n\r\n  QuantityBlocks.forEach(element => {\r\n    const quantityArrowMinus = element.querySelector('.quantity-arrow-minus');\r\n    const quantityArrowPlus = element.querySelector('.quantity-arrow-plus');\r\n\r\n    if (!quantityArrowMinus || !quantityArrowPlus) {\r\n      return;\r\n    }\r\n\r\n    const input = element.querySelector(`input`);\r\n\r\n    quantityArrowMinus.addEventListener('click', quantityMinus);\r\n    quantityArrowPlus.addEventListener('click', quantityPlus);\r\n\r\n    function quantityMinus(e) {\r\n      input.dispatchEvent(changeEvent);\r\n      if (input.value > 1) input.value = +input.value - 1;\r\n    }\r\n\r\n    function quantityPlus(e) {\r\n      input.dispatchEvent(changeEvent);\r\n      input.value = +input.value + 1;\r\n    }\r\n  });\r\n}\r\n\r\nquantityProducts();\r\njQuery(document).ajaxComplete(function () {\r\n  // as  after ajax loading form it elements are changed\r\n  quantityProducts();\r\n});\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/arrowsInputNumberStyle.js?");

/***/ }),

/***/ "../src/assets/js/modules/classHorizontalMenu.js":
/*!*******************************************************!*\
  !*** ../src/assets/js/modules/classHorizontalMenu.js ***!
  \*******************************************************/
/***/ (() => {

eval("/* \r\n    Обеспечивает основной функционал горизонтального меню для всех меню на странице\r\n        базовые стили в файле horizontalMenu.less\r\n\r\n        этим классом обрабатываются ТОЛЬКО теги nav с классами указанными в param.containersMenu\r\n        при переполнении контейнера пункты меню которые не поместились скрываются в меню overflow\r\n\r\n        click, нажатия клавиши esc прослушиваются на всей странице \r\n\r\n        по умолчанию выпадающие меню всех типов изначально создаются с внешним видом открытого состояния \r\n            и скрываются классом rmbt-hidden \r\n            для отрытия-активации меню класс rmbt-hidden удаляется \r\n        такое повидение можно изменить:\r\n            при открытии-активации меню любого типа ему добавляется класс rmbt-visible с соответствующим модификатором\r\n            это даёт возможность организовать разные способы открытия для разных пипо меню\r\n\r\n\r\n\r\n    todo:\r\n\r\n        исключить возможность открытия меню за пределы окна \r\n\r\n        добавить возможность устанавливать для каждого меню свой набор иконок, селекторами элементов которые уже прописаны в html\r\n\r\n        добавить все те манипуляции из dropprocessingClick() блокировка body и прочее\r\n        \r\n        возможность отключать icon - dropdown для меню desk top независимо от мобильной версии из html\r\n        overflow-cont  додлжен выезжать из за правой границы окна\r\n\r\n\r\n    */\r\n\r\nclass HorizontalMenu {\r\n  /*\r\n          const param = {\r\n              containersMenu: ['.cont-horizont-menu', '.wrap-drop-menu', '#my-menu'], // селекторы контейнеров меню которые будут обрабатываться\r\n              modifiers = {      // объект, модификаторы классов для различия разных типов меню\r\n                      drop:'drop',\r\n                      overflow:'overflow',\r\n                      burger:'burger',\r\n              }\r\n              \r\n              visibleClass: 'rmbt-visible', // классы для показа элементов\r\n              hiddenClass: 'rmbt-hidden', // классы для скрытия элементов\r\n\r\n              iconDropClass: '.icon-drop', // определяет внешний вид иконки когда subMenu закрыто \r\n              iconDropClassOpen: '.icon-drop_open', // Класс который определяет внешний вид иконки когда subMenu открыто. iconDropClass НЕбудет удалён\r\n              \r\n              iconOverflow: '.icon-overflow', // определяет внешний вид иконки overflow menu\r\n              iconOverflowOpen: '.icon-overflow_open', // определяет внешний вид иконки overflow menu когда overflow menu открыто\r\n              \r\n              iconBurger: 'icon-drop', // определяет внешний вид иконки Burgerr menu\r\n              iconBurgerOpen: 'icon-drop_open', // определяет внешний вид иконки Burgerr menu когда Burgerr menu открыто  iconBurger НЕбудет удалён\r\n\r\n              breakPointBurger: 768,      // размер окна при котором происходит перестроения в burger меню из overflow меню\r\n              \r\n              // single: 'false', // допускает одновременное открытие нескольких меню т.е. открытие следующего меню не закрывает предидущее\r\n\r\n              contAdditionalClasses: { // пользаватеьские классы определяющие внешний вид открытых пунтков меню или контейнеров\r\n                  drop: [],\r\n                  overflow: [],\r\n                  burger: [],\r\n              }, \r\n\r\n              animation = {     // для каждого вида меню ожидается объект содержащий все свойства/значения, которые вы хотите анимировать для открытия и закрытия отдельно!\r\n                              // соответствующий объект будет использован в методе gsap.to(). \r\n                 drop:{\r\n                     open{},\r\n                     close{}\r\n                 },\r\n                  overflow:{\r\n                      open{},\r\n                      close{}\r\n                  },\r\n                  burger:{\r\n                      open{},\r\n                      close{}\r\n                  },\r\n              } \r\n\r\n          };\r\n\r\n      */\r\n\r\n  // классы скрытых пунтков меню или контейнеров\r\n  hiddenMenuCont = {\r\n    overflow: 'overflow-cont',\r\n    drop: 'drop-cont',\r\n    burger: 'burger-cont',\r\n  };\r\n\r\n  // объект, модификаторы классов для того что бы каждый вид меню мог открываться - закрываться посвоему\r\n  modifiers = {\r\n    drop: 'drop',\r\n    overflow: 'overflow',\r\n    burger: 'burger',\r\n  };\r\n\r\n  // пользаватеьские классы определяющие внешний вид открытых пунтков меню или контейнеров\r\n  contAdditionalClasses = {\r\n    drop: [],\r\n    overflow: [],\r\n    burger: [],\r\n  };\r\n\r\n  animation = {\r\n    drop: {\r\n      open: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        height: 'auto',\r\n        overflow: 'visible',\r\n        pointerEvents: 'auto',\r\n        opacity: 1,\r\n        // width: 'auto',\r\n      },\r\n      close: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        height: 0,\r\n        overflow: 'hidden',\r\n        pointerEvents: 'none',\r\n        opacity: 0,\r\n        // width: 0,\r\n      },\r\n    },\r\n    overflow: {\r\n      open: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        height: 'auto',\r\n        overflow: 'visible',\r\n        pointerEvents: 'auto',\r\n        opacity: 1,\r\n        width: 'auto',\r\n      },\r\n      close: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        height: 0,\r\n        overflow: 'hidden',\r\n        pointerEvents: 'none',\r\n        opacity: 0,\r\n        width: 0,\r\n      },\r\n    },\r\n    burger: {\r\n      open: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        overflow: 'visible',\r\n        pointerEvents: 'auto',\r\n        opacity: 1,\r\n        width: 'auto',\r\n      },\r\n      close: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        overflow: 'hidden',\r\n        pointerEvents: 'none',\r\n        opacity: 0,\r\n        width: 0,\r\n      },\r\n    },\r\n  };\r\n\r\n  constructor(param) {\r\n    this.containersMenu = param.containersMenu || '.cont-horizont-menu';\r\n    this.nl_containersMenu = this._getArrNodeLists(this.containersMenu);\r\n    if (this.nl_containersMenu.length == 0) throw new Error('Menus with given selectors  are absent on this page');\r\n    this.contAdditionalClasses = param.contAdditionalClasses;\r\n    this.iconOverflow = this._clearClassName(param.iconOverflow || 'icon-overflow');\r\n    this.iconBurger = this._clearClassName(param.iconBurger || 'icon-burger');\r\n    this.iconBurgerOpen = this._clearClassName(param.iconBurgerOpen || 'icon-burger_open');\r\n    this.iconDropClass = this._clearClassName(param.iconDropClass || 'icon-drop');\r\n    this.iconDropClassOpen = this._clearClassName(param.iconDropdownmodifiereOpen || 'icon-drop_open');\r\n    this.breakPointBurger = param.breakPointBurger || 767;\r\n\r\n    this.visibleClass = this._clearClassName(param.visibleClass || 'rmbt-visible');\r\n    this.hiddenClass = this._clearClassName(param.hiddenClass || 'rmbt-hidden');\r\n    this.single = param.single || 'true';\r\n\r\n    this.lastWidthWindow = window.innerWidth;\r\n\r\n    this.forEachMenu();\r\n    this.listenClick();\r\n    this.listenKeydown();\r\n  }\r\n\r\n  forEachMenu() {\r\n    for (let index = 0; index < this.nl_containersMenu.length; index++) {\r\n      const arrNodeList = this.nl_containersMenu[index];\r\n\r\n      for (let i = 0; i <= arrNodeList.length - 1; i++) {\r\n        let contCurrentMenu = arrNodeList[i];\r\n        if (!contCurrentMenu.querySelector('nav')) continue;\r\n        this.monitoringResize(contCurrentMenu);\r\n        this.menuContainerDrop(contCurrentMenu);\r\n        this.setSubMenuIcon(contCurrentMenu);\r\n        this.setBurgerIcon(contCurrentMenu);\r\n      }\r\n    }\r\n  }\r\n\r\n  clearNav(contCurrentMenu) {\r\n    if (contCurrentMenu.querySelector('nav').classList.contains(this.hiddenClass) || contCurrentMenu.querySelector('nav').classList.contains(`${this.visibleClass}_${this.modifiers.burger}`)) {\r\n      contCurrentMenu.querySelector('nav').className = '';\r\n      if (typeof gsap !== 'undefined') {\r\n        Object.keys(this.animation.burger.close).forEach(prop => {\r\n          prop = prop.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\r\n          contCurrentMenu.querySelector('nav').style.setProperty(prop, '');\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  menuContainerOverflow(contCurrentMenu) {\r\n    let overflowCont = contCurrentMenu.querySelector(`.${this.hiddenMenuCont.overflow}`);\r\n    let ul = contCurrentMenu.querySelector('ul');\r\n    let createdOverflowCont = false;\r\n\r\n    if (overflowCont) {\r\n      if (overflowCont.childElementCount > 0) return overflowCont;\r\n    } else {\r\n      overflowCont = document.createElement('ul');\r\n      overflowCont.classList.add(this.hiddenMenuCont.overflow, this.hiddenClass);\r\n      createdOverflowCont = true;\r\n    }\r\n\r\n    this.clearNav(contCurrentMenu);\r\n\r\n    contCurrentMenu.querySelectorAll('nav>ul>li').forEach(elMenu => {\r\n      if (elMenu.getBoundingClientRect().right - ul.getBoundingClientRect().right > 1) {\r\n        overflowCont.append(elMenu);\r\n      }\r\n    });\r\n\r\n    if (overflowCont.childElementCount > 0) {\r\n      if (createdOverflowCont) {\r\n        contCurrentMenu.querySelector('nav').append(overflowCont);\r\n        this.setAdditionalClassesToCont(overflowCont, 'overflow');\r\n        contCurrentMenu.style.visibility = 'visible'; // показываю меню после окончательного формирования\r\n      }\r\n      if (!contCurrentMenu.querySelector(this.iconOverflow)) this.setOverflowIcon(contCurrentMenu);\r\n      return overflowCont;\r\n    }\r\n\r\n    contCurrentMenu.style.visibility = 'visible'; // показываю меню после окончательного формирования\r\n    return null;\r\n  }\r\n\r\n  monitoringResize(contCurrentMenu) {\r\n    const currentMenu = contCurrentMenu.querySelector('nav>ul:first-child');\r\n    const paddingRightCurrentMenu = +window.getComputedStyle(contCurrentMenu.querySelector('nav')).paddingRight.replace(/px/g, '');\r\n    const paddingRightcontCurrentMenu = +window.getComputedStyle(contCurrentMenu).paddingRight.replace(/px/g, '');\r\n    let prevRightCont = contCurrentMenu.getBoundingClientRect().right;\r\n\r\n    const observer = new ResizeObserver(entries => {\r\n      if (window.innerWidth <= this.breakPointBurger) {\r\n        contCurrentMenu.style.visibility = 'visible';\r\n        return;\r\n      }\r\n\r\n      if (contCurrentMenu.querySelector(`.${this.iconBurger}`).classList.contains(this.iconBurgerOpen)) {\r\n        this.changeStateIconMenu(contCurrentMenu.querySelector('nav'), this.modifiers.burger, 'close');\r\n      }\r\n\r\n      this.clearNav(contCurrentMenu);\r\n\r\n      let overflowCont = this.menuContainerOverflow(contCurrentMenu);\r\n      if (overflowCont === null) return;\r\n      let widthPrevFirstOverflowLi = 0;\r\n      let prevFirstOverflowLi = overflowCont.querySelector('li:first-child');\r\n      if (prevFirstOverflowLi) widthPrevFirstOverflowLi = prevFirstOverflowLi.getBoundingClientRect().width;\r\n\r\n      const mainUl = contCurrentMenu.querySelector('nav ul');\r\n      const currentRightMainUl = mainUl.getBoundingClientRect().right;\r\n      const currentRightCont = contCurrentMenu.getBoundingClientRect().right;\r\n\r\n      let prevlastLi, prevRightlastLi;\r\n      if (contCurrentMenu.querySelector('nav>ul:first-child>li:last-child')) {\r\n        prevlastLi = contCurrentMenu.querySelector('nav>ul:first-child>li:last-child');\r\n        prevRightlastLi = prevlastLi.getBoundingClientRect().right;\r\n      }\r\n\r\n      const sumDistanceBetweenLi = [...contCurrentMenu.querySelectorAll('nav>ul:first-child>li')].reduce((accum, li, i, arr) => {\r\n        if (arr[i + 1]) accum += arr[i + 1].getBoundingClientRect().left - li.getBoundingClientRect().right;\r\n        return accum;\r\n      }, 0);\r\n\r\n      if (currentRightCont - prevRightCont < 0) {\r\n        // окно уменьшается\r\n        if (prevRightlastLi > currentRightMainUl) overflowCont.prepend(prevlastLi);\r\n      } else {\r\n        // окно увеличивается\r\n        if (sumDistanceBetweenLi - widthPrevFirstOverflowLi > (paddingRightCurrentMenu + paddingRightcontCurrentMenu) * 2) {\r\n          if (prevFirstOverflowLi) currentMenu.append(prevFirstOverflowLi);\r\n          if (contCurrentMenu.querySelectorAll(`.${this.hiddenMenuCont.overflow}>li`).length == 0) {\r\n            if (contCurrentMenu.querySelector('.icon-overflow')) contCurrentMenu.querySelector('.icon-overflow').remove();\r\n          }\r\n        }\r\n      }\r\n      prevRightCont = currentRightCont;\r\n    });\r\n    observer.observe(contCurrentMenu);\r\n  }\r\n\r\n  menuContainerDrop(contCurrentMenu) {\r\n    let subMenus = contCurrentMenu.querySelectorAll('nav>ul ul');\r\n    if (subMenus.length > 0) {\r\n      subMenus.forEach(subMenu => {\r\n        subMenu.classList.add(this.hiddenMenuCont.drop, this.hiddenClass);\r\n        this.setAdditionalClassesToCont(subMenu, 'drop');\r\n      });\r\n    }\r\n  }\r\n\r\n  setAdditionalClassesToCont(currentMenu, typeMenu) {\r\n    if (typeMenu === 'overflow') {\r\n      classesIteration(this.contAdditionalClasses.overflow);\r\n    } else if (typeMenu === 'drop') {\r\n      classesIteration(this.contAdditionalClasses.drop);\r\n    } else if (typeMenu === 'burger') {\r\n      classesIteration(this.contAdditionalClasses.burger);\r\n    }\r\n\r\n    function classesIteration(arrClassies) {\r\n      arrClassies.forEach(_class => currentMenu.classList.add(_class));\r\n    }\r\n  }\r\n\r\n  /* \r\n          search sub menu and set sub menu icon if finde\r\n      */\r\n  setSubMenuIcon(contCurrentMenu) {\r\n    const itemsMenu = contCurrentMenu.querySelectorAll(`nav li`);\r\n    for (let i = 0; i <= itemsMenu.length - 1; i++) {\r\n      if (itemsMenu[i].querySelectorAll('ul').length === 0) continue; // Пропустить элементы без sub menu\r\n      let iconDropdown = document.createElement('div');\r\n      if (!itemsMenu[i].querySelector(`.${this.iconDropClass}`)) {\r\n        iconDropdown.classList.add(this.iconDropClass);\r\n      }\r\n      itemsMenu[i].append(iconDropdown);\r\n    }\r\n  }\r\n\r\n  setOverflowIcon(contCurrentMenu) {\r\n    let iconOverflow = document.createElement('div');\r\n    let span = document.createElement('span');\r\n    iconOverflow.append(span);\r\n    iconOverflow.classList.add(this.iconOverflow);\r\n    contCurrentMenu.querySelector('nav').append(iconOverflow);\r\n  }\r\n\r\n  setBurgerIcon(contCurrentMenu) {\r\n    let iconBurger = document.createElement('div');\r\n    let iconBurgerSpan = document.createElement('span');\r\n    iconBurger.classList.add(this.iconBurger);\r\n    iconBurger.append(iconBurgerSpan);\r\n    contCurrentMenu.prepend(iconBurger);\r\n  }\r\n\r\n  changeStateIconMenu(currentMenu, modifier, state) {\r\n    switch (modifier) {\r\n      case this.modifiers.drop:\r\n        let parentLi = currentMenu.closest('li');\r\n        if (parentLi === null) {\r\n          return;\r\n        }\r\n        parentLi.childNodes.forEach(node => {\r\n          try {\r\n            if (node.classList.contains(this.iconDropClass)) {\r\n              if (state == 'open') {\r\n                node.classList.add(this.iconDropClassOpen);\r\n                exit = true;\r\n                return;\r\n              } else if (state == 'close') {\r\n                node.classList.remove(this.iconDropClassOpen);\r\n                exit = true;\r\n                return;\r\n              }\r\n            }\r\n          } catch {}\r\n        });\r\n        break;\r\n\r\n      case this.modifiers.burger:\r\n        this.containersMenu.forEach(menuSel => {\r\n          let parrentMenu = currentMenu.closest(menuSel);\r\n\r\n          if (parrentMenu) {\r\n            let iconBurger = parrentMenu.querySelector(`.${this.iconBurger}`);\r\n\r\n            if (state == 'open') {\r\n              iconBurger.classList.add(this.iconBurgerOpen);\r\n              currentMenu.prepend(iconBurger);\r\n            } else if (state == 'close') {\r\n              iconBurger.classList.remove(this.iconBurgerOpen);\r\n              parrentMenu.append(iconBurger);\r\n            }\r\n          }\r\n        });\r\n\r\n        break;\r\n\r\n      case this.modifiers.overflow:\r\n        /*something*/\r\n        break;\r\n    }\r\n  }\r\n\r\n  closeMenu(currentMenu) {\r\n    let modifier;\r\n    if (currentMenu.classList.contains(this.visibleClass + '_' + this.modifiers.drop)) {\r\n      modifier = this.modifiers.drop;\r\n    } else if (currentMenu.classList.contains(this.visibleClass + '_' + this.modifiers.burger)) {\r\n      modifier = this.modifiers.burger;\r\n    } else if (currentMenu.classList.contains(this.visibleClass + '_' + this.modifiers.overflow)) {\r\n      modifier = this.modifiers.overflow;\r\n    }\r\n\r\n    if (typeof gsap !== 'undefined') {\r\n      if (modifier === this.modifiers.drop) {\r\n        gsap.to(currentMenu, this.animation.drop.close).play();\r\n      } else if (modifier === this.modifiers.overflow) {\r\n        gsap.to(currentMenu, this.animation.overflow.close).play();\r\n      } else if (modifier === this.modifiers.burger) {\r\n        gsap.to(currentMenu, this.animation.burger.close).play();\r\n      }\r\n    }\r\n\r\n    currentMenu.classList.remove(this.visibleClass + '_' + modifier);\r\n    currentMenu.classList.add(this.hiddenClass);\r\n\r\n    if (modifier === this.modifiers.burger) {\r\n      document.querySelector('html').classList.remove('rmbt-lock');\r\n    }\r\n    this.changeStateIconMenu(currentMenu, modifier, 'close');\r\n  }\r\n\r\n  OpenMenu(currentMenu, modifier) {\r\n    this.checSingle(currentMenu);\r\n\r\n    if (typeof gsap !== 'undefined') {\r\n      if (modifier === this.modifiers.drop) {\r\n        gsap.to(currentMenu, this.animation.drop.open).play();\r\n      } else if (modifier === this.modifiers.overflow) {\r\n        gsap.to(currentMenu, this.animation.overflow.open).play();\r\n      } else if (modifier === this.modifiers.burger) {\r\n        gsap.to(currentMenu, this.animation.burger.open).play();\r\n      }\r\n    } else {\r\n      currentMenu.classList.remove(this.hiddenClass);\r\n    }\r\n\r\n    if (modifier === this.modifiers.burger) {\r\n      document.querySelector('html').classList.add('rmbt-lock');\r\n      let overflowCont = currentMenu.querySelector(`.${this.hiddenMenuCont.overflow}`);\r\n      if (overflowCont) {\r\n        if (currentMenu.querySelectorAll(`.${this.hiddenMenuCont.overflow}>li`).length > 0) {\r\n          currentMenu.querySelectorAll(`.${this.hiddenMenuCont.overflow}>li`).forEach(li => {\r\n            currentMenu.querySelector('nav>ul:first-child').append(li);\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    currentMenu.classList.add(this.visibleClass + '_' + modifier);\r\n    this.changeStateIconMenu(currentMenu, modifier, 'open');\r\n  }\r\n\r\n  checSingle(currentMenu) {\r\n    if (this.single !== 'true') {\r\n      return null;\r\n    }\r\n\r\n    let flaf = 0;\r\n    let arr_values = Object.values(this.modifiers);\r\n\r\n    for (var i = arr_values.length - 1; i >= 0; i--) {\r\n      if (currentMenu.closest(`.${this.visibleClass}_${arr_values[i]}`)) {\r\n        flaf = 1;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (flaf == 0) {\r\n      let openedMenu = this._getAllOpenMenus();\r\n      if (openedMenu.length > 0) {\r\n        openedMenu.forEach(openedMenu => {\r\n          this.closeMenu(openedMenu); ///!!!!  проблема в том что this.animation.tween затирается следующим открытым меню\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  listenClick() {\r\n    document.addEventListener('click', e => {\r\n      let target = e.target;\r\n\r\n      if (target.classList.contains(this.iconDropClassOpen)) {\r\n        let parentMenu = target.closest('li');\r\n        let currentMenu = parentMenu.querySelector(`.${this.hiddenMenuCont.drop}`);\r\n        this.closeMenu(currentMenu);\r\n      } else if (target.classList.contains(this.iconBurgerOpen)) {\r\n        let currentMenu = target.closest(`.${this.visibleClass}_${this.modifiers.burger}`);\r\n        this.closeMenu(currentMenu);\r\n      } else if (target.classList.contains(this.iconDropClass)) {\r\n        let currentMenu = target.closest('li').querySelector(`.${this.hiddenMenuCont.drop}`);\r\n        this.OpenMenu(currentMenu, this.modifiers.drop);\r\n      } else if (target.classList.contains(this.iconOverflow) || target.closest(`.${this.iconOverflow}`)) {\r\n        let currentMenu = target.closest('nav').querySelector(`.${this.hiddenMenuCont.overflow}`);\r\n        this.OpenMenu(currentMenu, this.modifiers.overflow);\r\n      } else if (target.classList.contains(this.iconBurger)) {\r\n        this.containersMenu.forEach(menuSel => {\r\n          if (target.closest(menuSel)) {\r\n            let currentMenu = target.closest(menuSel).querySelector(`nav`);\r\n            this.OpenMenu(currentMenu, this.modifiers.burger);\r\n          }\r\n        });\r\n      } else {\r\n        this.clickOut();\r\n      }\r\n    });\r\n  }\r\n\r\n  clickOut() {\r\n    let nl_menus = this._getAllOpenMenus();\r\n\r\n    if (nl_menus.length > 0)\r\n      nl_menus.forEach(menu => {\r\n        this.closeMenu(menu);\r\n      });\r\n  }\r\n\r\n  listenKeydown() {\r\n    document.addEventListener('keydown', e => {\r\n      if (e.key === 27 || e.keyCode === 27) {\r\n        let nl_menus = this._getAllOpenMenus();\r\n        if (nl_menus.length > 0)\r\n          nl_menus.forEach(menu => {\r\n            this.closeMenu(menu, 'drop');\r\n          });\r\n      }\r\n    });\r\n  }\r\n\r\n  //========= helpers ============\r\n\r\n  /*\r\n          удаляет повторяющиеся значения\r\n      */\r\n  _uniqueArr(arr) {\r\n    return [\r\n      ...new Set(\r\n        arr\r\n          .map(el => {\r\n            if (typeof str === 'string') this._clearClassName(el);\r\n          })\r\n          .filter(item => item !== undefined)\r\n      ),\r\n    ];\r\n  }\r\n\r\n  /*\r\n            очистка имён классов\r\n        */\r\n\r\n  _clearClassName(str) {\r\n    if (typeof str !== 'string') {\r\n      return '';\r\n    }\r\n    const patternDot = /^\\./;\r\n    return str.replace(patternDot, '');\r\n  }\r\n\r\n  /*\r\n            возвращает массив nodeList элементов по их селекторам\r\n        */\r\n  _getArrNodeLists(date) {\r\n    if (Array.isArray(date)) {\r\n      let nl_menus = date\r\n        .map(el => document.querySelectorAll(el))\r\n        .filter((menu, index, nodeList) => {\r\n          if (menu.length > 0) {\r\n            return menu;\r\n          }\r\n        });\r\n\r\n      return nl_menus;\r\n    }\r\n  }\r\n\r\n  /*\r\n          преобразует одномерный массив из n-мерного массива\r\n      */\r\n  _flattenArray(arr) {\r\n    let flatArray = [];\r\n    arr.forEach(element => {\r\n      if (Array.isArray(element)) {\r\n        flatArray.push(...this._flattenArray(element));\r\n      } else {\r\n        flatArray.push(element);\r\n      }\r\n    });\r\n\r\n    return this._uniqueArr(flatArray);\r\n  }\r\n\r\n  _getAllOpenMenus() {\r\n    let entries = Object.entries(this.modifiers);\r\n    let arr_menu = entries.map(([key, mod]) => [...document.querySelectorAll(`.${this.visibleClass}_${mod}`)]);\r\n    arr_menu = arr_menu.flat();\r\n\r\n    return arr_menu;\r\n  }\r\n}\r\n\r\nconst param = {\r\n  containersMenu: ['.cont-horizont-menu', '.wrap-drop-menu', '#my-menu'],\r\n  contAdditionalClasses: {\r\n    drop: ['add-drop-1', 'add-drop-2', 'add-drop-3'],\r\n    overflow: ['add-overflow-1', 'add-overflow-2', 'add-overflow-3'],\r\n    burger: ['add-burger-1', 'add-burger-2', 'add-burger-3'],\r\n  },\r\n  // animation: {\r\n  //     drop: {},\r\n  //     overflow: {},\r\n  //     burger: {},\r\n  // }\r\n};\r\n\r\nconst menu = new HorizontalMenu(param);\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/classHorizontalMenu.js?");

/***/ }),

/***/ "../src/assets/js/modules/dynamic_adapt.js":
/*!*************************************************!*\
  !*** ../src/assets/js/modules/dynamic_adapt.js ***!
  \*************************************************/
/***/ (() => {

"use strict";
eval("// Dynamic Adapt v.1\r\n// HTML data-da=\"where(uniq class name),when(breakpoint),position(ordinal number - dig or first or last)\"\r\n// e.x. data-da=\".item,992,2\"\r\n// Andrikanych Yevhen 2020\r\n// https://www.youtube.com/c/freelancerlifestyle\r\n\r\n\r\nfunction DynamicAdapt(type) {\r\n  this.type = type;\r\n}\r\nDynamicAdapt.prototype.init = function () {\r\n  const _this = this;\r\n  // массив объектов\r\n  this.оbjects = [];\r\n  this.daClassname = '_dynamic_adapt_';\r\n  // массив DOM-элементов\r\n  this.nodes = document.querySelectorAll('[data-da]');\r\n  // наполнение оbjects объктами\r\n  for (let i = 0; i < this.nodes.length; i++) {\r\n    const node = this.nodes[i];\r\n    const data = node.dataset.da.trim();\r\n    const dataArray = data.split(',');\r\n    const оbject = {};\r\n    оbject.element = node;\r\n    оbject.parent = node.parentNode;\r\n    оbject.destination = document.querySelector(dataArray[0].trim());\r\n    оbject.breakpoint = dataArray[1] ? dataArray[1].trim() : '767';\r\n    оbject.place = dataArray[2] ? dataArray[2].trim() : 'last';\r\n    оbject.index = this.indexInParent(оbject.parent, оbject.element);\r\n    this.оbjects.push(оbject);\r\n  }\r\n  this.arraySort(this.оbjects);\r\n  // массив уникальных медиа-запросов\r\n  this.mediaQueries = Array.prototype.map.call(\r\n    this.оbjects,\r\n    function (item) {\r\n      return '(' + this.type + '-width: ' + item.breakpoint + 'px),' + item.breakpoint;\r\n    },\r\n    this\r\n  );\r\n  this.mediaQueries = Array.prototype.filter.call(this.mediaQueries, function (item, index, self) {\r\n    return Array.prototype.indexOf.call(self, item) === index;\r\n  });\r\n  // навешивание слушателя на медиа-запрос\r\n  // и вызов обработчика при первом запуске\r\n  for (let i = 0; i < this.mediaQueries.length; i++) {\r\n    const media = this.mediaQueries[i];\r\n    const mediaSplit = String.prototype.split.call(media, ',');\r\n    const matchMedia = window.matchMedia(mediaSplit[0]);\r\n    const mediaBreakpoint = mediaSplit[1];\r\n    // массив объектов с подходящим брейкпоинтом\r\n    const оbjectsFilter = Array.prototype.filter.call(this.оbjects, function (item) {\r\n      return item.breakpoint === mediaBreakpoint;\r\n    });\r\n    matchMedia.addListener(function () {\r\n      _this.mediaHandler(matchMedia, оbjectsFilter);\r\n    });\r\n    this.mediaHandler(matchMedia, оbjectsFilter);\r\n  }\r\n};\r\nDynamicAdapt.prototype.mediaHandler = function (matchMedia, оbjects) {\r\n  if (matchMedia.matches) {\r\n    for (let i = 0; i < оbjects.length; i++) {\r\n      const оbject = оbjects[i];\r\n      оbject.index = this.indexInParent(оbject.parent, оbject.element);\r\n      this.moveTo(оbject.place, оbject.element, оbject.destination);\r\n    }\r\n  } else {\r\n    //for (let i = 0; i < оbjects.length; i++) {\r\n    for (let i = оbjects.length - 1; i >= 0; i--) {\r\n      const оbject = оbjects[i];\r\n      if (оbject.element.classList.contains(this.daClassname)) {\r\n        this.moveBack(оbject.parent, оbject.element, оbject.index);\r\n      }\r\n    }\r\n  }\r\n};\r\n// Функция перемещения\r\nDynamicAdapt.prototype.moveTo = function (place, element, destination) {\r\n  element.classList.add(this.daClassname);\r\n  if (place === 'last' || place >= destination.children.length) {\r\n    destination.insertAdjacentElement('beforeend', element);\r\n    return;\r\n  }\r\n  if (place === 'first') {\r\n    destination.insertAdjacentElement('afterbegin', element);\r\n    return;\r\n  }\r\n  destination.children[place].insertAdjacentElement('beforebegin', element);\r\n};\r\n// Функция возврата\r\nDynamicAdapt.prototype.moveBack = function (parent, element, index) {\r\n  element.classList.remove(this.daClassname);\r\n  if (parent.children[index] !== undefined) {\r\n    parent.children[index].insertAdjacentElement('beforebegin', element);\r\n  } else {\r\n    parent.insertAdjacentElement('beforeend', element);\r\n  }\r\n};\r\n// Функция получения индекса внутри родителя\r\nDynamicAdapt.prototype.indexInParent = function (parent, element) {\r\n  const array = Array.prototype.slice.call(parent.children);\r\n  return Array.prototype.indexOf.call(array, element);\r\n};\r\n// Функция сортировки массива по breakpoint и place\r\n// по возрастанию для this.type = min\r\n// по убыванию для this.type = max\r\nDynamicAdapt.prototype.arraySort = function (arr) {\r\n  if (this.type === 'min') {\r\n    Array.prototype.sort.call(arr, function (a, b) {\r\n      if (a.breakpoint === b.breakpoint) {\r\n        if (a.place === b.place) {\r\n          return 0;\r\n        }\r\n\r\n        if (a.place === 'first' || b.place === 'last') {\r\n          return -1;\r\n        }\r\n\r\n        if (a.place === 'last' || b.place === 'first') {\r\n          return 1;\r\n        }\r\n\r\n        return a.place - b.place;\r\n      }\r\n\r\n      return a.breakpoint - b.breakpoint;\r\n    });\r\n  } else {\r\n    Array.prototype.sort.call(arr, function (a, b) {\r\n      if (a.breakpoint === b.breakpoint) {\r\n        if (a.place === b.place) {\r\n          return 0;\r\n        }\r\n\r\n        if (a.place === 'first' || b.place === 'last') {\r\n          return 1;\r\n        }\r\n\r\n        if (a.place === 'last' || b.place === 'first') {\r\n          return -1;\r\n        }\r\n\r\n        return b.place - a.place;\r\n      }\r\n\r\n      return b.breakpoint - a.breakpoint;\r\n    });\r\n    return;\r\n  }\r\n};\r\nconst da = new DynamicAdapt('max');\r\nda.init();\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/dynamic_adapt.js?");

/***/ }),

/***/ "../src/assets/js/modules/functions.js":
/*!*********************************************!*\
  !*** ../src/assets/js/modules/functions.js ***!
  \*********************************************/
/***/ (() => {

eval("/* Проверка мобильного браузера */\r\nisMobile = {\r\n    Android: function() { return navigator.userAgent.match(/Android/i); },\r\n    BlackBerry: function() { return navigator.userAgent.match(/BlackBerry/i); },\r\n    iOS: function() { return navigator.userAgent.match(/iPhone|iPad|iPod/i); },\r\n    Opera: function() { return navigator.userAgent.match(/Opera Mini/i); },\r\n    Windows: function() { return navigator.userAgent.match(/IEMobile/i); },\r\n    any: function() { return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()); }\r\n};\r\n\r\n/* Добавление класса touch для тега htl если браузер мобильный */\r\nfunction addTouchClass() {\r\n    if (isMobile.any()) document.documentElement.classList.add('touch');\r\n}\r\naddTouchClass();\r\n\r\n/* Проверка поддерживает ли браузер webp */\r\nfunction testWebp(callback) {\r\n    let webP = new Image();\r\n    webP.onload = webP.onerror = function() {\r\n        callback(webP.height == 2);\r\n    };\r\n    webP.src = \"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA\";\r\n}\r\ntestWebp(function(support) {\r\n    let className = support === true ? 'webp' : 'no-webp';\r\n    document.documentElement.classList.add(className);\r\n});\r\n\r\n/* Smooth scrolling when clicking.\r\n *  scrolling to sections pointed into param data-goto\r\n *  Set element to which  will be scroll. For example a header with position: fixed. \r\n *  Element to which  will be scroll must have attribute data-gotoOffset\r\n */\r\nlet toWhichWillBeScroll = document.querySelector('[data-gotoOffset]');\r\ntoWhichWillBeScroll = toWhichWillBeScroll ? (toWhichWillBeScroll.offsetHeight + toWhichWillBeScroll.offsetTop) : 0;\r\nconst gotoLinks = document.querySelectorAll('[data-goto]');\r\nif (gotoLinks.length > 0) {\r\n    gotoLinks.forEach(gotoLink => {\r\n        gotoLink.addEventListener('click', onGotoLinkCick);\r\n    });\r\n\r\n    function onGotoLinkCick(e) {\r\n        const gotoLink = e.target;\r\n        if (gotoLink.dataset.goto && document.querySelector(gotoLink.dataset.goto)) {\r\n            const gotoBlock = document.querySelector(gotoLink.dataset.goto);\r\n            const gotoBlockValue = gotoBlock.getBoundingClientRect().top + pageYOffset - toWhichWillBeScroll;\r\n\r\n            window.scrollTo({\r\n                top: gotoBlockValue,\r\n                behavior: 'smooth',\r\n            });\r\n\r\n            e.preventDefault();\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/functions.js?");

/***/ }),

/***/ "../src/assets/js/modules/popup.js":
/*!*****************************************!*\
  !*** ../src/assets/js/modules/popup.js ***!
  \*****************************************/
/***/ (() => {

eval("const mainContainerClass = 'rmbt-page-wrap'; // class your main container\r\nconst timeout = 800; // the quantity  of milliseconds must be equal to the animation time in the 'transition' property in the file popup.js\r\n\r\nconst popupLinks = document.querySelectorAll('.popup-link');\r\nconst body = document.querySelector('body');\r\nconst lockPadding = document.querySelectorAll('.lockPadding');\r\n\r\nlet unLock = true;\r\n\r\nif (popupLinks.length > 0) {\r\n  for (let i = 0; i < popupLinks.length; i++) {\r\n    const popupLink = popupLinks[i];\r\n    popupLink.addEventListener('click', function (e) {\r\n      const popupName = popupLink.getAttribute('href').replace('#', '');\r\n      const currentPopup = document.getElementById(popupName);\r\n      popupOpen(currentPopup);\r\n      e.preventDefault();\r\n    });\r\n  }\r\n}\r\nconst popupCloseIcon = document.querySelectorAll('.popup__close-window');\r\nif (popupCloseIcon.length > 0) {\r\n  for (var i = 0; i < popupCloseIcon.length; i++) {\r\n    const el = popupCloseIcon[i];\r\n    el.addEventListener('click', function (e) {\r\n      e.preventDefault();\r\n      popupClose(el.closest('.popup'));\r\n    });\r\n  }\r\n}\r\n\r\nfunction popupOpen(currentPopup) {\r\n  if (currentPopup && unLock) {\r\n    const popupActive = document.querySelector('.popup.open');\r\n    if (popupActive) {\r\n      popupClose(popupActive, false);\r\n    } else {\r\n      bodyLock();\r\n    }\r\n    currentPopup.classList.add('open');\r\n    currentPopup.addEventListener('click', function (e) {\r\n      if (!e.target.closest('.popup__body')) {\r\n        popupClose(e.target.closest('.popup'));\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction popupClose(popupActive, downLock = true) {\r\n  if (unLock) {\r\n    popupActive.classList.remove('open');\r\n    if (downLock) {\r\n      bodyUnLock();\r\n    }\r\n  }\r\n}\r\n\r\nfunction bodyLock() {\r\n  const lockPaddingValue = window.innerWidth - document.querySelector(`.${mainContainerClass}`).offsetWidth + 'px';\r\n  if (lockPadding.length > 0) {\r\n    for (let i = 0; i < lockPadding.length; i++) {\r\n      const el = lockPadding[i];\r\n      el.style.paddingRight = lockPaddingValue;\r\n    }\r\n  }\r\n  body.style.paddingRight = lockPaddingValue;\r\n  body.classList.add('lock');\r\n  unLock = false;\r\n  setTimeout(function () {\r\n    unLock = true;\r\n  }, timeout);\r\n}\r\n\r\nfunction bodyUnLock() {\r\n  setTimeout(function () {\r\n    if (lockPadding.length > 0) {\r\n      for (let i = 0; i < lockPadding.length; i++) {\r\n        const el = lockPadding[i];\r\n        el.style.paddingRight = '0px';\r\n      }\r\n    }\r\n    body.style.paddingRight = '0px';\r\n    body.classList.remove('lock');\r\n  }, timeout);\r\n  unLock = false;\r\n  setTimeout(function () {\r\n    unLock = true;\r\n  }, timeout);\r\n}\r\n\r\ndocument.addEventListener('keydown', function (e) {\r\n  if (e.which === 27 && document.querySelector('.popup.open')) {\r\n    const popupActive = document.querySelector('.popup.open');\r\n    popupClose(popupActive);\r\n  }\r\n});\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/popup.js?");

/***/ }),

/***/ "../src/assets/js/modules/sliders.js":
/*!*******************************************!*\
  !*** ../src/assets/js/modules/sliders.js ***!
  \*******************************************/
/***/ (() => {

eval("if (document.querySelector('.rmbt-clients-portfolio-swiper')) {\r\n  swiperParam = new Swiper('.rmbt-clients-portfolio-swiper', {\r\n    direction: 'horizontal',\r\n    loop: true,\r\n\r\n    speed: 1400,\r\n    autoplay: {\r\n      delay: 1000,\r\n    },\r\n\r\n    // slidesPerView: 4,\r\n    slidesPerView: 'auto',\r\n    spaceBetween: 60,\r\n\r\n    breakpoints: {\r\n      768: {\r\n        spaceBetween: 20,\r\n        centeredSlidesBounds: true,\r\n      },\r\n      640: {\r\n        spaceBetween: 10,\r\n      },\r\n    },\r\n  });\r\n}\r\n\r\nif (document.querySelector('.rmbt-single-post-swiper')) {\r\n  swiperParam = new Swiper('.rmbt-single-post-swiper', {\r\n    direction: 'horizontal',\r\n    loop: true,\r\n\r\n    slidesPerView: 3,\r\n    spaceBetween: 40,\r\n    centeredSlides: true,\r\n    centerInsufficientSlides: true,\r\n\r\n    navigation: {\r\n      nextEl: '.button-next',\r\n      prevEl: '.button-prev',\r\n    },\r\n\r\n    speed: 1400,\r\n    autoplay: {\r\n      delay: 5000,\r\n    },\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/sliders.js?");

/***/ }),

/***/ "../src/assets/js/modules/spoiler.js":
/*!*******************************************!*\
  !*** ../src/assets/js/modules/spoiler.js ***!
  \*******************************************/
/***/ (() => {

eval("/*\r\n *\r\n * \tSimple spoiler\r\n *\tThe styles in the file spoiler.less\r\n *\r\n */\r\n\r\nfunction spoiler() {\r\n\r\n    const spoilers = document.querySelectorAll('.spoiler__title');\r\n\r\n    spoilers.forEach(spoiler => {\r\n        spoiler.addEventListener('click', e => {\r\n            spoilerText = e.target.closest('.spoiler').querySelector('.spoiler__text');\r\n            spoilerText.classList.toggle('open');\r\n            e.target.classList.toggle('spoiler__title_open');\r\n            if (spoilerText.classList.contains('open')) {\r\n                if (spoilerText) {\r\n                    gsap.to(spoilerText, {\r\n                        duration: 0.5,\r\n                        ease: \"power1.in\",\r\n                        height: 'auto',\r\n                        overflow: 'visible',\r\n                        pointerEvents: 'auto',\r\n                        opacity: 1,\r\n                    });\r\n                }\r\n            } else {\r\n                gsap.to(spoilerText, {\r\n                    duration: 0.5,\r\n                    ease: \"power1.in\",\r\n                    height: '0px',\r\n                    overflow: 'hidden',\r\n                    pointerEvents: 'none',\r\n                    opacity: 0,\r\n                });\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\nspoiler();\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/spoiler.js?");

/***/ }),

/***/ "../src/assets/js/modules/tabs.js":
/*!****************************************!*\
  !*** ../src/assets/js/modules/tabs.js ***!
  \****************************************/
/***/ (() => {

eval("const tabs = document.querySelectorAll(\".tab\");\r\n\r\n\r\n\r\n\r\nif (tabs) {\r\n    tabs.forEach(tab => {\r\n        tab.addEventListener(\"click\", e => {\r\n            const tabName = e.target.dataset.tab;\r\n            const tabsContainer = e.target.closest(\".tabs\");\r\n            const tabsItem = tabsContainer.querySelectorAll(\".tabs__item\");\r\n\r\n            tabsItem.forEach(tabItem => {\r\n                if (tabItem.getAttribute('data-tab-target') === tabName) {\r\n                    tabItem.classList.add(\"active\");\r\n                } else if (tabItem.classList.contains(\"active\")) {\r\n                    tabItem.classList.remove(\"active\")\r\n                }\r\n\r\n            })\r\n\r\n\r\n\r\n        })\r\n    })\r\n}\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/tabs.js?");

/***/ }),

/***/ "../src/assets/js/app.js":
/*!*******************************!*\
  !*** ../src/assets/js/app.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/functions.js */ \"../src/assets/js/modules/functions.js\");\n/* harmony import */ var _modules_dynamic_adapt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/dynamic_adapt.js */ \"../src/assets/js/modules/dynamic_adapt.js\");\n/* harmony import */ var _modules_popup_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/popup.js */ \"../src/assets/js/modules/popup.js\");\n/* harmony import */ var _modules_spoiler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/spoiler.js */ \"../src/assets/js/modules/spoiler.js\");\n/* harmony import */ var _modules_tabs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/tabs.js */ \"../src/assets/js/modules/tabs.js\");\n/* harmony import */ var _modules_arrowsInputNumberStyle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/arrowsInputNumberStyle.js */ \"../src/assets/js/modules/arrowsInputNumberStyle.js\");\n/* harmony import */ var _modules_classHorizontalMenu_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/classHorizontalMenu.js */ \"../src/assets/js/modules/classHorizontalMenu.js\");\n/* harmony import */ var _modules_sliders_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/sliders.js */ \"../src/assets/js/modules/sliders.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* Start the video when it is scrolled into view to the viewport */\r\n// Function to check element visibility\r\nfunction isElementInViewport(el) {\r\n  var rect = el.getBoundingClientRect();\r\n  return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);\r\n}\r\n\r\n// Function to start video\r\nfunction playVideoWhenVisible() {\r\n  const videoBlock = document.getElementById('rmbt-promo-video');\r\n  if (!videoBlock) {\r\n    return;\r\n  }\r\n  if (isElementInViewport(videoBlock)) {\r\n    const video = videoBlock.querySelector('iframe');\r\n    video.src = video.src.replace('autoplay=0', 'autoplay=1');\r\n    window.removeEventListener('scroll', playVideoWhenVisible);\r\n  }\r\n}\r\nwindow.addEventListener('scroll', playVideoWhenVisible);\r\n\r\nconst contactFeedbackForm = document.querySelector('#contact-feedback-form');\r\nif (contactFeedbackForm) {\r\n  document.addEventListener('click', e => {\r\n    if (e.target.id === 'contactFeedbackFormSubmit') {\r\n      // e.preventDefault();\r\n    }\r\n  });\r\n}\r\n\r\ndocument.addEventListener('click', e => {\r\n  const target = e.target;\r\n\r\n  if (target.classList.contains('.rmbt-phones-for-mobile') || target.closest('.rmbt-phones-for-mobile')) {\r\n    target.closest('.rmbt-phones-for-mobile').querySelector('.rmbt-phones-for-mobile__body').classList.toggle('active');\r\n  } else {\r\n    // клик мимо\r\n    document.querySelector('.rmbt-phones-for-mobile__body').classList.remove('active');\r\n  }\r\n});\r\n\r\n/* =============  changing structure of blocks for different screens  ============= */\r\n\r\nconst logo = document.querySelector('.custom-logo-link');\r\nconst contHorizontMenu = document.querySelector('.cont-horizont-menu');\r\n\r\nconst contactForm = document.querySelector('#contact-feedback-form');\r\nlet buttonSubmitContactFeedbackForm;\r\nif (contactForm) {\r\n  buttonSubmitContactFeedbackForm = contactForm.querySelector('.submit-wrap');\r\n}\r\n\r\nif (window.innerWidth <= 767) {\r\n  document.querySelector('.rmbt-top-row').prepend(logo);\r\n  document.querySelector('.rmbt-top-row').append(contHorizontMenu);\r\n  if (window.innerWidth < 670) {\r\n    if (buttonSubmitContactFeedbackForm) {\r\n      contactForm.querySelector('.rmbt-contacts-feedback-form__input-wrap').append(buttonSubmitContactFeedbackForm);\r\n    }\r\n    if (window.innerWidth < 482) {\r\n      if (buttonSubmitContactFeedbackForm) {\r\n        contactForm.querySelector('.rmbt-contacts-feedback-form').append(buttonSubmitContactFeedbackForm);\r\n      }\r\n    }\r\n  }\r\n} else if (window.innerWidth > 767) {\r\n  document.querySelector('.rmbt-bottom-row').prepend(logo);\r\n  document.querySelector('.rmbt-bottom-row').append(contHorizontMenu);\r\n}\r\n\r\nwindow.addEventListener('resize', resizeScreen);\r\nfunction resizeScreen(e) {\r\n  if (window.innerWidth <= 767) {\r\n    document.querySelector('.rmbt-top-row').prepend(logo);\r\n    document.querySelector('.rmbt-top-row').append(contHorizontMenu);\r\n\r\n    contactForm.querySelector('.rmbt-contacts-feedback-form').append(buttonSubmitContactFeedbackForm);\r\n    if (window.innerWidth < 670) {\r\n      if (buttonSubmitContactFeedbackForm) {\r\n        contactForm.querySelector('.rmbt-contacts-feedback-form__input-wrap').append(buttonSubmitContactFeedbackForm);\r\n      }\r\n      if (window.innerWidth < 482) {\r\n        if (buttonSubmitContactFeedbackForm) {\r\n          contactForm.querySelector('.rmbt-contacts-feedback-form').append(buttonSubmitContactFeedbackForm);\r\n        }\r\n      }\r\n    }\r\n  } else if (window.innerWidth > 767) {\r\n    document.querySelector('.rmbt-bottom-row').prepend(logo);\r\n    document.querySelector('.rmbt-bottom-row').append(contHorizontMenu);\r\n  }\r\n}\r\n\r\nconst url = new URL(window.location.href);\r\n\r\n// скрыл переключение языков\r\nif (decodeURIComponent(url.pathname).indexOf('группа-категории') > 0 || decodeURIComponent(url.pathname).indexOf('группа-категорий') > 0) {\r\n  document.querySelector('.pll-parent-menu-item').style.display = 'none';\r\n}\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/app.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("../src/assets/js/app.js");
/******/ 	
/******/ })()
;